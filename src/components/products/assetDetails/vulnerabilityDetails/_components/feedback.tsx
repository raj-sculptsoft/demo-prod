import CustomButton from "@/components/core/custom-button";
import { Card } from "@/components/ui/card";
import { Checkbox } from "@/components/ui/checkbox";
import { ToggleGroup, ToggleGroupItem } from "@/components/ui/toggle-group";
import { useAppDispatch, useAppSelector } from "@/hooks/use-store";
import { toast } from "@/hooks/use-toast";
import { IError } from "@/lib/fetcher/types";

import {
  addOrEditFeedback,
  getFalsePositivityReasonOptions,
  getFeedbackDetails,
  getPositivity,
  getTruePositivityReasonOptions,
} from "@/store/vulnerabilities/api";
import { FeedbackDetails } from "@/types/vulnerability";
import { useEffect, useState } from "react";

interface FeedbackProps {
  positivity: boolean;
  vulnerabilityId: string;
}

// Define an interface for the feedback response
interface FeedbackResponse {
  payload: {
    data: {
      false_positivity?: boolean;
      false_positivity_reason?: string;
      true_positivity?: boolean;
      true_positivity_reason?: string;
    };
  };
}

export default function Feedback({
  positivity,
  vulnerabilityId,
}: FeedbackProps) {
  const dispatch = useAppDispatch();
  const reasonsList = useAppSelector(
    ({ vulnerability }) => vulnerability.reasons?.list || [],
  );
  const positivityOptions = useAppSelector(
    ({ vulnerability }) => vulnerability.positivity.list,
  );
  const loading = useAppSelector(({ vulnerability }) => vulnerability.loading);

  const [toggleSelection, setToggleSelection] = useState<string>("");
  const [isCheckboxChecked, setIsCheckboxChecked] = useState<
    boolean | "indeterminate"
  >(false);
  const [reasonSelection, setReasonSelection] = useState<string>("");

  useEffect(() => {
    dispatch(getPositivity());
  }, [dispatch]);

  useEffect(() => {
    if (positivity) {
      const fetchTruePositivityReasons = () => {
        dispatch(getTruePositivityReasonOptions());
      };
      fetchTruePositivityReasons();
    }
  }, [dispatch, positivity]);

  useEffect(() => {
    if (!positivity) {
      const fetchFalsePositivityReasons = () => {
        dispatch(getFalsePositivityReasonOptions());
      };
      fetchFalsePositivityReasons();
    }
  }, [dispatch, positivity]);

  // Fetch the existing feedback details and set initial state
  useEffect(() => {
    const fetchFeedback = async () => {
      const feedbackResponse = (await dispatch(
        getFeedbackDetails(vulnerabilityId),
      )) as FeedbackResponse;

      if (feedbackResponse?.payload?.data) {
        const {
          false_positivity,
          false_positivity_reason,
          true_positivity,
          true_positivity_reason,
        } = feedbackResponse.payload.data;

        if (false_positivity && false_positivity_reason !== undefined) {
          setToggleSelection("incorrect");
          setReasonSelection(false_positivity_reason);
        } else if (true_positivity && true_positivity_reason !== undefined) {
          setToggleSelection("correct");
          setReasonSelection(true_positivity_reason);
        }
      }
    };

    fetchFeedback();
  }, [dispatch, vulnerabilityId]);

  // Determine whether to enable Submit button
  const isSubmitEnabled =
    (toggleSelection === "correct" || !!toggleSelection || isCheckboxChecked) &&
    (toggleSelection === "correct" || !!reasonSelection);

  // Handle Submit Button Click
  const handleSubmit = async () => {
    const payload: FeedbackDetails = {
      vulnerability_id: vulnerabilityId,
      false_positivity: null as string | null,
      false_positivity_reason: null,
      true_positivity: null,
      true_positivity_reason: null,
    };

    // If positivity is not selected and toggleSelection is "incorrect", set false positivity
    if (toggleSelection === "incorrect") {
      payload.false_positivity = positivityOptions[1]?.master_enum_uuid ?? null;
      payload.false_positivity_reason = reasonSelection;
    }

    // If positivity is selected (checkbox is checked), handle false positivity as well
    if (isCheckboxChecked !== "indeterminate") {
      payload.true_positivity = positivityOptions[0]?.master_enum_uuid ?? null;
      payload.true_positivity_reason = reasonSelection;
    }

    // If toggleSelection is "correct", set true positivity without requiring a reason
    if (toggleSelection === "correct") {
      payload.true_positivity = positivityOptions[0]?.master_enum_uuid ?? null;
      payload.true_positivity_reason = reasonSelection || null;
    }

    try {
      // Dispatch and unwrap the result to access the message
      const { message } = await dispatch(addOrEditFeedback(payload)).unwrap();
      toast({ title: message });
    } catch (error) {
      toast({
        title: (error as IError)?.message ?? "Something went wrong",
        variant: "destructive",
      });
    }
  };

  return (
    <Card className="mb-10">
      <h3 className="border-b p-4 text-lg font-bold">Feedback</h3>
      <div className="space-y-4 p-4">
        <div className="space-y-3">
          {!positivity && (
            <>
              <p className="text-base font-bold text-borderColor-dark">
                False Positive:
              </p>
              <ToggleGroup
                className="justify-start gap-3"
                variant="outline"
                type="single"
                value={toggleSelection}
                onValueChange={(value) => {
                  setToggleSelection(value);

                  // Clear reasonSelection if "Incorrect" is not selected
                  if (value !== "incorrect") {
                    setReasonSelection("");
                  }
                }}
              >
                <ToggleGroupItem value="correct" aria-label="Toggle correct">
                  Correct
                </ToggleGroupItem>
                <ToggleGroupItem
                  value="incorrect"
                  aria-label="Toggle incorrect"
                >
                  Incorrect
                </ToggleGroupItem>
              </ToggleGroup>
            </>
          )}
          {positivity && (
            <>
              <p className="text-base font-bold text-borderColor-dark">
                Mark as False Positive:
              </p>
              <Checkbox
                id="false-positive"
                className="size-7 rounded-md border-borderColor-dark"
                checked={isCheckboxChecked}
                onCheckedChange={(checked) => setIsCheckboxChecked(checked)}
              />
            </>
          )}
        </div>
        <div className="space-y-3">
          {((!positivity && toggleSelection === "incorrect") ||
            isCheckboxChecked) && (
            <>
              <p className="text-base font-bold text-borderColor-dark">
                Reason:
              </p>
              <ToggleGroup
                className="flex-wrap justify-start gap-3"
                variant="outline"
                type="single"
                value={reasonSelection}
                onValueChange={(value) => setReasonSelection(value)}
              >
                {reasonsList.map((reason) => (
                  <ToggleGroupItem
                    key={reason.master_enum_uuid}
                    value={reason.master_enum_uuid}
                    aria-label={reason.master_enum_name}
                  >
                    {reason.master_enum_name}
                  </ToggleGroupItem>
                ))}
              </ToggleGroup>
            </>
          )}
        </div>

        <CustomButton
          className="px-12 py-4"
          disabled={!isSubmitEnabled}
          onClick={handleSubmit}
          isLoading={loading}
        >
          Submit
        </CustomButton>
      </div>
    </Card>
  );
}
